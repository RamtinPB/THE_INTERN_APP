// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// USER ENUMS
// =============================================================================

enum UserType {
  CUSTOMER
  BUSINESS
  // ADMIN // Deprecated - use separate Admin entity
}

enum UserStatus {
  ACTIVE
  SUSPENDED
}

// =============================================================================
// ADMIN ENUMS
// =============================================================================

/// Admin types - supports multiple roles with different permissions
enum AdminType {
  SUPER_ADMIN // Full system access
  SUPPORT_ADMIN // Customer support, account management
  FINANCE_ADMIN // Finance operations
  RISK_ADMIN // Risk management, fraud detection
  BUSINESS_ADMIN // Business user management
}

/// Admin account status
enum AdminStatus {
  ACTIVE
  SUSPENDED
  DEACTIVATED
}

// =============================================================================
// USER MODEL
// =============================================================================

model User {
  id           Int      @id @default(autoincrement())
  publicId     String   @unique @default(cuid())
  phoneNumber  String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  otps                OTP[]
  refreshTokens       RefreshToken[]
  revokedAccessTokens RevokedAccessToken[]

  userType UserType   @default(CUSTOMER)
  status   UserStatus @default(ACTIVE)

  wallets        Wallet[]
  paymentIntents PaymentIntent[] // Future: for card/top-up payments

  // Admin relation - 1:1 (only exists for admin users)
  admin Admin?

  @@index([phoneNumber])
}

// =============================================================================
// ADMIN MODEL
// =============================================================================

/// Separate admin entity - 1:1 relation with User
/// Allows multiple admin types and admin-specific metadata
model Admin {
  /// Primary key
  id Int @id @default(autoincrement())

  /// Public-facing ID for sharing/admin references
  publicId String @unique @default(cuid())

  /// Type of admin - determines permissions
  adminType AdminType

  /// Account status
  status AdminStatus @default(ACTIVE)

  /// Department (e.g., "Finance", "Support", "Operations", "Risk")
  department String?

  /// Granular permissions array (can override type-based defaults)
  permissions String[]

  /// Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Last login timestamp
  lastLoginAt DateTime?

  // ========================================================================
  // RELATIONS
  // ========================================================================

  /// 1:1 relation to User - admin is a User with additional admin properties
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int  @unique

  /// Audit trail of all admin actions
  adminAuditLogs AdminAuditLog[]

  // ========================================================================
  // INDEXES
  // ========================================================================
  @@index([adminType])
  @@index([status])
}

// =============================================================================
// ADMIN AUDIT LOG MODEL
// =============================================================================

/// Comprehensive audit log for ALL admin actions
/// Tracks who did what, when, and from where
model AdminAuditLog {
  /// Primary key
  id Int @id @default(autoincrement())

  /// Action performed
  /// Examples: USER_SUSPENDED, WALLET_ADJUSTED, TRANSACTION_REFUNDED,
  ///           ADMIN_CREATED, PASSWORD_CHANGED, LOGIN_FAILED
  action String

  /// Type of entity affected (e.g., "Transaction", "Wallet", "User", "Admin")
  entityType String

  /// ID of the affected entity
  entityId Int

  /// Human-readable description of the action
  description String?

  /// Flexible metadata storage
  /// Stores: old/new values, request details, response data, etc.
  metadata Json?

  /// IP address of the admin when performing the action
  ipAddress String?

  /// User agent string
  userAgent String?

  /// Timestamp of the action
  createdAt DateTime @default(now())

  // ========================================================================
  // RELATIONS
  // ========================================================================

  /// The admin who performed this action
  admin   Admin @relation(fields: [adminId], references: [id])
  adminId Int

  // ========================================================================
  // INDEXES
  // ========================================================================
  @@index([adminId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([action])
}

// =============================================================================
// OTP MODELS
// =============================================================================

model OTP {
  id          Int        @id @default(autoincrement())
  phoneNumber String
  codeHash    String
  expiresAt   DateTime
  consumed    Boolean    @default(false)
  purpose     OTPPurpose

  user   User? @relation(fields: [userId], references: [id])
  userId Int?

  createdAt DateTime @default(now())

  @@index([phoneNumber])
}

enum OTPPurpose {
  LOGIN
  SIGNUP
  VERIFY_TRANSACTION
}

// =============================================================================
// TOKEN MODELS
// =============================================================================

model RefreshToken {
  id        Int      @id @default(autoincrement())
  tokenHash String
  revoked   Boolean  @default(false)
  expiresAt DateTime

  user   User @relation(fields: [userId], references: [id])
  userId Int

  createdAt DateTime @default(now())
}

model RevokedAccessToken {
  id        Int      @id @default(autoincrement())
  tokenHash String   @unique
  expiresAt DateTime

  user   User @relation(fields: [userId], references: [id])
  userId Int

  createdAt DateTime @default(now())

  @@index([tokenHash])
  @@index([userId])
}

// =============================================================================
// WALLET & TRANSACTION MODELS
// =============================================================================

model Wallet {
  id        Int      @id @default(autoincrement())
  publicId  String   @unique @default(cuid())
  balance   Decimal  @db.Decimal(18, 2)
  primary   Boolean  @default(false)
  frozen    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User @relation(fields: [userId], references: [id])
  userId Int

  ledgerEntries  LedgerEntry[]
  paymentIntents PaymentIntent[] // Future: for card/top-up payments

  // Two separate relations to Transaction (for payer and receiver)
  payerTransactions    Transaction[] @relation("PayerWallet")
  receiverTransactions Transaction[] @relation("ReceiverWallet")

  @@index([userId])
}

model Transaction {
  id               Int               @id @default(autoincrement())
  publicId         String            @unique @default(cuid())
  status           TransactionStatus
  transactionType  TransactionType
  transferType     TransferType? // OWN_WALLET or P2P (only for TRANSFER type)
  amount           Decimal           @db.Decimal(18, 2)
  payerWalletId    Int
  receiverWalletId Int?
  createdAt        DateTime          @default(now())
  description      String? // For product name, merchant info, etc.
  metadata         Json? // For flexible storage of receipt-specific data

  // Two separate relations to Wallet (for payer and receiver)
  payerWallet    Wallet  @relation("PayerWallet", fields: [payerWalletId], references: [id])
  receiverWallet Wallet? @relation("ReceiverWallet", fields: [receiverWalletId], references: [id])

  ledgerEntries LedgerEntry[]
  invoice       Invoice? // Future: for billing/requesting payment from users
}

enum TransactionType {
  TRANSFER
  DEPOSIT
  WITHDRAW
  PURCHASE
  REFUND
  ADMIN_ADJUSTMENT
}

enum TransferType {
  OWN_WALLET // Transfer between user's own wallets
  P2P // Transfer to another user's wallet
}

enum TransactionStatus {
  PENDING
  OTP_VERIFIED
  COMPLETED
  FAILED
}

model LedgerEntry {
  id            Int         @id @default(autoincrement())
  walletId      Int
  wallet        Wallet      @relation(fields: [walletId], references: [id])
  transactionId Int
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  type          LedgerType
  amount        Decimal     @db.Decimal(18, 2)
  createdAt     DateTime    @default(now())

  @@index([walletId])
  @@index([transactionId])
}

enum LedgerType {
  WITHDRAW
  DEPOSIT
  P2P
  PURCHASE
  REFUND
}

// =============================================================================
// FUTURE USE MODELS - Uncomment and implement when needed
// =============================================================================

/// Invoice - For requesting payment from another user
/// Use case: Business users can send invoices/bills to customers
/// Example: "User A requests $50 from User B"
model Invoice {
  id            Int         @id @default(autoincrement())
  publicId      String      @unique @default(cuid())
  transactionId Int         @unique
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  issuedAt      DateTime
  metadata      Json
}

/// PaymentIntent - For external payment methods (Stripe-style)
/// Use case: Add money to wallet via card payment
/// Flow: Create PaymentIntent -> Collect card -> Confirm -> Add to wallet
/// Status: PENDING -> OTP_SENT -> CONFIRMED/EXPIRED
model PaymentIntent {
  id        Int                 @id @default(autoincrement())
  publicId  String              @unique @default(cuid())
  userId    Int
  user      User                @relation(fields: [userId], references: [id])
  walletId  Int
  wallet    Wallet              @relation(fields: [walletId], references: [id])
  amount    Decimal             @db.Decimal(18, 2)
  otpId     Int?
  expiresAt DateTime
  status    PaymentIntentStatus
  createdAt DateTime            @default(now())
}

enum PaymentIntentStatus {
  PENDING // Created, awaiting payment
  OTP_SENT // OTP sent for verification
  CONFIRMED // Payment successful, funds added to wallet
  EXPIRED // Payment expired
}
