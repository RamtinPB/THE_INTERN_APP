// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum UserType {
  CUSTOMER
  BUSINESS
  ADMIN
}

model User {
  id           Int      @id @default(autoincrement())
  publicId     String   @unique @default(cuid())
  phoneNumber  String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  otps          OTP[]
  refreshTokens RefreshToken[]

  userType            UserType             @default(CUSTOMER)
  revokedAccessTokens RevokedAccessToken[]

  wallets        Wallet[]
  paymentIntents PaymentIntent[] // Future: for card/top-up payments
}

model OTP {
  id          Int        @id @default(autoincrement())
  phoneNumber String
  codeHash    String
  expiresAt   DateTime
  consumed    Boolean    @default(false)
  purpose     OTPPurpose

  user   User? @relation(fields: [userId], references: [id])
  userId Int?

  createdAt DateTime @default(now())

  @@index([phoneNumber])
}

enum OTPPurpose {
  LOGIN
  SIGNUP
  VERIFY_TRANSACTION
}

model RefreshToken {
  id        Int      @id @default(autoincrement())
  tokenHash String
  revoked   Boolean  @default(false)
  expiresAt DateTime

  user   User @relation(fields: [userId], references: [id])
  userId Int

  createdAt DateTime @default(now())
}

model RevokedAccessToken {
  id        Int      @id @default(autoincrement())
  tokenHash String   @unique
  expiresAt DateTime

  user   User @relation(fields: [userId], references: [id])
  userId Int

  createdAt DateTime @default(now())

  @@index([tokenHash])
  @@index([userId])
}

model Wallet {
  id        Int      @id @default(autoincrement())
  publicId  String   @unique @default(cuid())
  balance   Decimal  @db.Decimal(18, 2)
  primary   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User @relation(fields: [userId], references: [id])
  userId Int

  ledgerEntries  LedgerEntry[]
  paymentIntents PaymentIntent[] // Future: for card/top-up payments

  // Two separate relations to Transaction (for payer and receiver)
  payerTransactions    Transaction[] @relation("PayerWallet")
  receiverTransactions Transaction[] @relation("ReceiverWallet")

  @@index([userId])
}

model Transaction {
  id               Int               @id @default(autoincrement())
  publicId         String            @unique @default(cuid())
  status           TransactionStatus
  transactionType  TransactionType
  transferType     TransferType? // OWN_WALLET or P2P (only for TRANSFER type)
  amount           Decimal           @db.Decimal(18, 2)
  payerWalletId    Int
  receiverWalletId Int?
  createdAt        DateTime          @default(now())

  // Two separate relations to Wallet (for payer and receiver)
  payerWallet    Wallet  @relation("PayerWallet", fields: [payerWalletId], references: [id])
  receiverWallet Wallet? @relation("ReceiverWallet", fields: [receiverWalletId], references: [id])

  ledgerEntries LedgerEntry[]
  invoice       Invoice? // Future: for billing/requesting payment from users
}

enum TransactionType {
  TRANSFER
  DEPOSIT
  WITHDRAW
  PURCHASE
  REFUND
  ADMIN_ADJUSTMENT
}

enum TransferType {
  OWN_WALLET // Transfer between user's own wallets
  P2P // Transfer to another user's wallet
}

enum TransactionStatus {
  PENDING
  OTP_VERIFIED
  COMPLETED
  FAILED
}

model LedgerEntry {
  id            Int         @id @default(autoincrement())
  walletId      Int
  wallet        Wallet      @relation(fields: [walletId], references: [id])
  transactionId Int
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  type          LedgerType
  amount        Decimal     @db.Decimal(18, 2)
  createdAt     DateTime    @default(now())

  @@index([walletId])
  @@index([transactionId])
}

enum LedgerType {
  WITHDRAW
  DEPOSIT
  P2P
  PURCHASE
  REFUND
}

// =============================================================================
// FUTURE USE MODELS - Uncomment and implement when needed
// =============================================================================

/// Invoice - For requesting payment from another user
/// Use case: Business users can send invoices/bills to customers
/// Example: "User A requests $50 from User B"
model Invoice {
  id            Int         @id @default(autoincrement())
  publicId      String      @unique @default(cuid())
  transactionId Int         @unique
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  issuedAt      DateTime
  metadata      Json
}

/// PaymentIntent - For external payment methods (Stripe-style)
/// Use case: Add money to wallet via card payment
/// Flow: Create PaymentIntent -> Collect card -> Confirm -> Add to wallet
/// Status: PENDING -> OTP_SENT -> CONFIRMED/EXPIRED
model PaymentIntent {
  id        Int                 @id @default(autoincrement())
  publicId  String              @unique @default(cuid())
  userId    Int
  user      User                @relation(fields: [userId], references: [id])
  walletId  Int
  wallet    Wallet              @relation(fields: [walletId], references: [id])
  amount    Decimal             @db.Decimal(18, 2)
  otpId     Int?
  expiresAt DateTime
  status    PaymentIntentStatus
  createdAt DateTime            @default(now())
}

enum PaymentIntentStatus {
  PENDING // Created, awaiting payment
  OTP_SENT // OTP sent for verification
  CONFIRMED // Payment successful, funds added to wallet
  EXPIRED // Payment expired
}
